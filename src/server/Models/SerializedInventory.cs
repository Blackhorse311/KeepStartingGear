// ============================================================================
// Keep Starting Gear - Serialized Inventory Models
// ============================================================================
// These data classes represent the structure of inventory items in a format
// that matches SPT's profile JSON structure. This ensures compatibility
// when restoring items to the player's profile.
//
// SPT PROFILE ITEM STRUCTURE:
// {
//   "_id": "unique-item-id",
//   "_tpl": "template-id",
//   "parentId": "parent-container-id",
//   "slotId": "Backpack" or "main" etc,
//   "location": { "x": 0, "y": 0, "r": 0 },
//   "upd": { "StackObjectsCount": 30, ... }
// }
//
// CLASS HIERARCHY:
// - SerializedItem: Main item class with all properties
// - ItemLocation: Grid position for items in containers
// - ItemUpd: Dynamic item state (stack count, durability, etc.)
// - UpdFoldable: Folding weapon state
// - Tag: Custom item naming/coloring
//
// AUTHOR: Blackhorse311
// LICENSE: MIT
// ============================================================================

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Blackhorse311.KeepStartingGear.Converters;

namespace Blackhorse311.KeepStartingGear.Models;

/// <summary>
/// Represents a serialized inventory item in JSON-friendly format.
/// Matches SPT's profile inventory structure for direct compatibility.
/// </summary>
/// <remarks>
/// <para>
/// Each item in the inventory is represented by this class. Items form
/// a hierarchical structure through ParentId references:
/// </para>
/// <list type="bullet">
///   <item>Equipment container is the root (template 55d7217a4bdc2d86028b456d)</item>
///   <item>Equipment slot items have Equipment as parent</item>
///   <item>Nested items (mods, contents) have their container as parent</item>
/// </list>
/// <para>
/// <b>JSON Property Names:</b> Use underscores (_id, _tpl) to match SPT's format.
/// This is important for compatibility with the server-side restoration.
/// </para>
/// </remarks>
public class SerializedItem
{
    /// <summary>
    /// Unique identifier for this specific item instance.
    /// Generated by EFT/SPT when the item is created.
    /// </summary>
    /// <example>"5c0647fdd443c22b77659123"</example>
    [JsonProperty("_id")]
    public string Id { get; set; }

    /// <summary>
    /// Template ID defining what type of item this is.
    /// References the item's definition in the database.
    /// </summary>
    /// <example>"5447a9cd4bdc2dbd208b4567" for AKS-74U</example>
    [JsonProperty("_tpl")]
    public string Tpl { get; set; }

    /// <summary>
    /// ID of the parent item/container this item is inside.
    /// Used to build the item hierarchy during restoration.
    /// </summary>
    /// <remarks>
    /// For items in equipment slots, this is the Equipment container ID.
    /// For nested items, this is their immediate parent container/weapon.
    /// </remarks>
    [JsonProperty("parentId")]
    public string ParentId { get; set; }

    /// <summary>
    /// Slot or grid identifier where this item is placed.
    /// </summary>
    /// <remarks>
    /// Values include:
    /// <list type="bullet">
    ///   <item>Equipment slots: "FirstPrimaryWeapon", "Backpack", "TacticalVest"</item>
    ///   <item>Container grids: "main" (most containers use this)</item>
    ///   <item>Weapon mods: "mod_stock", "mod_magazine", "mod_muzzle"</item>
    ///   <item>Magazine ammo: "cartridges"</item>
    /// </list>
    /// </remarks>
    [JsonProperty("slotId")]
    public string SlotId { get; set; }

    /// <summary>
    /// Grid position for items inside containers.
    /// Only populated for items in grid containers (backpacks, rigs, pockets).
    /// For magazine cartridges, this will be null and LocationIndex is used instead.
    /// </summary>
    /// <remarks>
    /// Access this property to get grid position data. For serialization,
    /// use the LocationData property which handles polymorphic output.
    /// </remarks>
    [JsonIgnore]
    public ItemLocation? Location { get; set; }

    /// <summary>
    /// Numeric position index for cartridges in magazines.
    /// In SPT profiles, cartridges use a simple integer location (0, 1, 2, etc.)
    /// instead of the grid-style location object used by container items.
    /// </summary>
    /// <remarks>
    /// Access this property to get cartridge index. For serialization,
    /// use the LocationData property which handles polymorphic output.
    /// </remarks>
    [JsonIgnore]
    public int? LocationIndex { get; set; }

    /// <summary>
    /// Polymorphic location data for JSON serialization.
    /// Uses a custom converter to handle both grid positions (objects) and cartridge indices (integers).
    /// </summary>
    /// <remarks>
    /// <para>SPT profiles use different location formats:</para>
    /// <list type="bullet">
    ///   <item>Grid items: {"x": 0, "y": 0, "r": 0, "isSearched": true}</item>
    ///   <item>Magazine cartridges: 0 (simple integer)</item>
    /// </list>
    /// <para>
    /// This property uses <see cref="LocationConverter"/> to handle both cases.
    /// When reading, access <see cref="Location"/> or <see cref="LocationIndex"/> directly.
    /// </para>
    /// </remarks>
    [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
    [JsonConverter(typeof(LocationConverter))]
    public LocationConverter.LocationResult? LocationData
    {
        get
        {
            // Return appropriate result based on what data we have
            if (LocationIndex.HasValue)
                return new LocationConverter.LocationResult { CartridgeIndex = LocationIndex.Value };

            if (Location != null)
                return new LocationConverter.LocationResult { GridLocation = Location };

            return null;
        }
        set
        {
            if (value == null)
            {
                Location = null;
                LocationIndex = null;
                return;
            }

            if (value.IsCartridge)
            {
                LocationIndex = value.CartridgeIndex;
                Location = null;
            }
            else if (value.IsGrid)
            {
                Location = value.GridLocation;
                LocationIndex = null;
            }
        }
    }

    /// <summary>
    /// Helper method to set location from a grid position.
    /// </summary>
    public void SetGridLocation(ItemLocation location)
    {
        Location = location;
        LocationIndex = null;
    }

    /// <summary>
    /// Helper method to set location from a cartridge index.
    /// </summary>
    /// <exception cref="ArgumentOutOfRangeException">If index is negative</exception>
    public void SetCartridgeIndex(int index)
    {
        if (index < 0)
            throw new ArgumentOutOfRangeException(nameof(index), "Cartridge index cannot be negative");

        LocationIndex = index;
        Location = null;
    }

    /// <summary>
    /// Update/state data for the item (stack count, durability, etc.).
    /// Contains dynamic properties that can change during gameplay.
    /// </summary>
    [JsonProperty("upd")]
    public ItemUpd Upd { get; set; }
}

/// <summary>
/// Represents an item's position within a grid container.
/// Used for items in backpacks, rigs, pockets, and other grid-based storage.
/// </summary>
/// <remarks>
/// <para>
/// Grid coordinates start at (0,0) in the top-left corner.
/// The rotation value determines whether the item is placed
/// horizontally or vertically in the grid.
/// </para>
/// </remarks>
public class ItemLocation
{
    /// <summary>
    /// X coordinate (horizontal position) in the grid.
    /// 0 is the leftmost column.
    /// </summary>
    [JsonProperty("x")]
    public int X { get; set; }

    /// <summary>
    /// Y coordinate (vertical position) in the grid.
    /// 0 is the topmost row.
    /// </summary>
    [JsonProperty("y")]
    public int Y { get; set; }

    /// <summary>
    /// Rotation state of the item in the grid.
    /// 0 = Horizontal (default), 1 = Vertical (rotated 90 degrees).
    /// </summary>
    [JsonProperty("r")]
    public int R { get; set; }

    /// <summary>
    /// Whether this item has been searched/inspected.
    /// True for player-owned items, false for unexamined loot.
    /// </summary>
    [JsonProperty("isSearched")]
    public bool IsSearched { get; set; }
}

/// <summary>
/// Item update/state data containing dynamic properties.
/// This holds values that can change during gameplay.
/// </summary>
/// <remarks>
/// <para>
/// Not all properties apply to all items. For example:
/// </para>
/// <list type="bullet">
///   <item>StackObjectsCount: Only for stackable items (ammo, money, meds)</item>
///   <item>SpawnedInSession: True if item was found during current raid</item>
///   <item>Foldable: Only for weapons with folding stocks</item>
///   <item>MedKit: Medical item durability/HP remaining</item>
///   <item>Repairable: Armor and weapon durability</item>
///   <item>Resource: Consumable resource (fuel, etc.)</item>
///   <item>FoodDrink: Food and drink resource</item>
///   <item>Tag: Only for items with custom names/colors</item>
/// </list>
/// </remarks>
public class ItemUpd
{
    /// <summary>
    /// Stack count for stackable items (ammunition, money, medical supplies).
    /// Null for non-stackable items or items with count of 1.
    /// </summary>
    /// <example>30 for a stack of 30 rounds</example>
    [JsonProperty("StackObjectsCount")]
    public long? StackObjectsCount { get; set; }

    /// <summary>
    /// Whether this item was found/spawned during the current session.
    /// True = "Found in Raid" status, False = brought into raid.
    /// </summary>
    [JsonProperty("SpawnedInSession")]
    public bool SpawnedInSession { get; set; }

    /// <summary>
    /// Folding state for weapons with folding stocks.
    /// Only present on applicable weapons.
    /// </summary>
    [JsonProperty("Foldable")]
    public UpdFoldable Foldable { get; set; }

    /// <summary>
    /// Medical item durability (HP remaining).
    /// Used for IFAK, AFAK, Grizzly, etc.
    /// </summary>
    [JsonProperty("MedKit")]
    public UpdMedKit MedKit { get; set; }

    /// <summary>
    /// Durability for repairable items (armor, weapons).
    /// Contains current and max durability values.
    /// </summary>
    [JsonProperty("Repairable")]
    public UpdRepairable Repairable { get; set; }

    /// <summary>
    /// Resource value for consumable items (fuel cans, etc.).
    /// </summary>
    [JsonProperty("Resource")]
    public UpdResource Resource { get; set; }

    /// <summary>
    /// Food and drink resource value.
    /// </summary>
    [JsonProperty("FoodDrink")]
    public UpdFoodDrink FoodDrink { get; set; }

    /// <summary>
    /// Custom tag/name applied to this item by the player.
    /// Used for organization and identification.
    /// </summary>
    [JsonProperty("Tag")]
    public Tag Tag { get; set; }

    /// <summary>
    /// Dogtag metadata containing kill information.
    /// Only present on dogtag items.
    /// </summary>
    [JsonProperty("Dogtag")]
    public UpdDogtag Dogtag { get; set; }

    /// <summary>
    /// Key information for keys with limited uses.
    /// </summary>
    [JsonProperty("Key")]
    public UpdKey Key { get; set; }
}

/// <summary>
/// Medical kit durability/HP remaining.
/// </summary>
public class UpdMedKit
{
    /// <summary>
    /// Current HP value of the medical item.
    /// </summary>
    [JsonProperty("HpResource")]
    public double HpResource { get; set; }
}

/// <summary>
/// Durability for repairable items (armor, weapons).
/// </summary>
public class UpdRepairable
{
    /// <summary>
    /// Current durability value.
    /// </summary>
    [JsonProperty("Durability")]
    public double Durability { get; set; }

    /// <summary>
    /// Maximum durability value.
    /// </summary>
    [JsonProperty("MaxDurability")]
    public double MaxDurability { get; set; }
}

/// <summary>
/// Resource value for consumable items.
/// </summary>
public class UpdResource
{
    /// <summary>
    /// Current resource value.
    /// </summary>
    [JsonProperty("Value")]
    public double Value { get; set; }
}

/// <summary>
/// Food and drink resource value.
/// </summary>
public class UpdFoodDrink
{
    /// <summary>
    /// Current HP/resource value of the food or drink.
    /// </summary>
    [JsonProperty("HpPercent")]
    public double HpPercent { get; set; }
}

/// <summary>
/// Folding state for weapons with collapsible/folding stocks.
/// </summary>
/// <remarks>
/// Some weapons (like AKS-74U, MP5K) can fold their stocks to
/// reduce the item size in containers. This state is preserved
/// in the snapshot.
/// </remarks>
public class UpdFoldable
{
    /// <summary>
    /// Whether the weapon's stock is currently folded.
    /// True = folded (smaller), False = unfolded (full size).
    /// </summary>
    [JsonProperty("Folded")]
    public bool Folded { get; set; }
}

/// <summary>
/// Custom tag/label applied to an item by the player.
/// Allows naming and color-coding items for organization.
/// </summary>
/// <remarks>
/// Players can tag items with custom names and colors using
/// the in-game "Tag" option in the context menu.
/// </remarks>
public class Tag
{
    /// <summary>
    /// Custom name/label for the item.
    /// </summary>
    /// <example>"Main AK", "Scav Killer"</example>
    [JsonProperty("Name")]
    public string Name { get; set; }

    /// <summary>
    /// Color code for the tag.
    /// Integer value representing the selected color.
    /// </summary>
    [JsonProperty("Color")]
    public int Color { get; set; }
}

/// <summary>
/// Dogtag metadata containing information about a kill.
/// Dogtags are special items that record who was killed, by whom, and when.
/// </summary>
/// <remarks>
/// This metadata is critical for dogtags to be valid - without it,
/// the dogtag appears "wiped" or invalid in the game.
/// </remarks>
public class UpdDogtag
{
    /// <summary>Account ID of the killed player</summary>
    [JsonProperty("AccountId")]
    public string AccountId { get; set; }

    /// <summary>Profile ID of the killed player</summary>
    [JsonProperty("ProfileId")]
    public string ProfileId { get; set; }

    /// <summary>Nickname of the killed player</summary>
    [JsonProperty("Nickname")]
    public string Nickname { get; set; }

    /// <summary>Faction side of the killed player (Bear/Usec)</summary>
    [JsonProperty("Side")]
    public string Side { get; set; }

    /// <summary>Level of the killed player at time of death</summary>
    [JsonProperty("Level")]
    public int Level { get; set; }

    /// <summary>Time/date when the kill occurred (ISO 8601 format)</summary>
    [JsonProperty("Time")]
    public string Time { get; set; }

    /// <summary>Status of the kill</summary>
    [JsonProperty("Status")]
    public string Status { get; set; }

    /// <summary>Account ID of the killer</summary>
    [JsonProperty("KillerAccountId")]
    public string KillerAccountId { get; set; }

    /// <summary>Profile ID of the killer</summary>
    [JsonProperty("KillerProfileId")]
    public string KillerProfileId { get; set; }

    /// <summary>Nickname of the killer</summary>
    [JsonProperty("KillerName")]
    public string KillerName { get; set; }

    /// <summary>Name of the weapon used for the kill</summary>
    [JsonProperty("WeaponName")]
    public string WeaponName { get; set; }
}

/// <summary>
/// Key information for keys with limited uses.
/// Some keys in Tarkov have a limited number of uses before they break.
/// </summary>
public class UpdKey
{
    /// <summary>Number of uses remaining on the key</summary>
    [JsonProperty("NumberOfUsages")]
    public int NumberOfUsages { get; set; }
}
